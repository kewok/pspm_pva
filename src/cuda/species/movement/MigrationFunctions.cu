#include <species/movement/migration_behavior.h>

void MigrationBehavior::determine_destination(inds_stochastic_migratory *species)
	{
	/*
	* A generic template for the code that determines the destinations of individuals, based on the migration matrix between sites. This is to be populated by code generated by the user.
	*/
	thrust::device_vector<float> rand(size);
	float *rand_ptr = raw_pointer_cast(&rand[0]);
	
	//Draw from the alias table to determine destinations;
	curandGenerateUniform(random_gen, rand_ptr, size);
	species->Migration_Matrix.adjust_randoms(rand.begin(), rand.end(), migration_offsets.begin(), migration_offsets.end(), species->deme.begin(), species->deme.begin() + size);

	species->Migration_Matrix.draw(rand.begin(), rand.end(), migrant_destinations.begin());

	// adjust value to reflect actual deme rather than index of migration_matrix (i.e., deflatten so that (i-1)*n + j = j)
	thrust::transform(migrant_destinations.begin(), migrant_destinations.begin() + size, migrant_destinations.begin(), unary_modulus<unsigned int>(Number_of_Demes));
	}

void MigrationBehavior::determine_if_individuals_migrate(inds_stochastic_migratory *species)
	{
	/*
	* A generic template for the code that decides whether individuals will migrate during each time step. 
	*/	
	thrust::device_vector<float> rand(size);
	float *rand_ptr = raw_pointer_cast(&rand[0]);
	//Draw bernoulli to determine if they will migrate
	curandGenerateUniform(random_gen, rand_ptr, size);
	
	thrust::for_each(thrust::make_zip_iterator(thrust::make_tuple(will_migrate.begin(), species->individual_migration_rate.begin(), rand.begin())),
        		 thrust::make_zip_iterator(thrust::make_tuple(will_migrate.begin() + size, species->individual_migration_rate.begin() + size, rand.begin() + size)),
			 determine_if_migratory());
	}

void MigrationBehavior::move_individuals(inds_stochastic_migratory *species)
	{	
	/*
	* A generic function that simulates the migration of individuals during each time step by reassining their demes. 
	*/
	determine_destination(species);
	cudaThreadSynchronize();

	determine_if_individuals_migrate(species);

	cudaThreadSynchronize();

	thrust::for_each(thrust::make_zip_iterator(thrust::make_tuple(species->deme.begin(), will_migrate.begin(), migrant_destinations.begin())),
        		 thrust::make_zip_iterator(thrust::make_tuple(species->deme.begin() + size, will_migrate.begin() + size, migrant_destinations.begin() + size)),
			 move_individuals_functor());
	}
